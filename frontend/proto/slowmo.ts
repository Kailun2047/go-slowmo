// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "slowmo.proto" (package "slowmo", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message slowmo.CompileAndRunRequest
 */
export interface CompileAndRunRequest {
    /**
     * @generated from protobuf field: optional string source = 1
     */
    source?: string; // Go source code from user.
}
/**
 * @generated from protobuf message slowmo.CompileAndRunResponse
 */
export interface CompileAndRunResponse {
    /**
     * @generated from protobuf oneof: compile_and_run_oneof
     */
    compileAndRunOneof: {
        oneofKind: "compileError";
        /**
         * @generated from protobuf field: slowmo.CompilationError compile_error = 1
         */
        compileError: CompilationError;
    } | {
        oneofKind: "runtimeError";
        /**
         * @generated from protobuf field: slowmo.RuntimeError runtime_error = 2
         */
        runtimeError: RuntimeError;
    } | {
        oneofKind: "runEvent";
        /**
         * @generated from protobuf field: slowmo.ProbeEvent run_event = 3
         */
        runEvent: ProbeEvent;
    } | {
        oneofKind: "runtimeOutput";
        /**
         * @generated from protobuf field: slowmo.RuntimeOutput runtime_output = 4
         */
        runtimeOutput: RuntimeOutput;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message slowmo.CompilationError
 */
export interface CompilationError {
    /**
     * @generated from protobuf field: optional string error_message = 1
     */
    errorMessage?: string;
}
/**
 * @generated from protobuf message slowmo.RuntimeError
 */
export interface RuntimeError {
    /**
     * @generated from protobuf field: optional string error_message = 1
     */
    errorMessage?: string;
}
/**
 * @generated from protobuf message slowmo.ProbeEvent
 */
export interface ProbeEvent {
    /**
     * @generated from protobuf oneof: probe_event_oneof
     */
    probeEventOneof: {
        oneofKind: "runqStatusEvent";
        /**
         * @generated from protobuf field: slowmo.RunqStatusEvent runq_status_event = 1
         */
        runqStatusEvent: RunqStatusEvent;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message slowmo.RunqStatusEvent
 */
export interface RunqStatusEvent {
    /**
     * @generated from protobuf field: optional int64 proc_id = 1
     */
    procId?: bigint;
    /**
     * @generated from protobuf field: slowmo.InterpretedPC current_pc = 2
     */
    currentPc?: InterpretedPC;
    /**
     * @generated from protobuf field: repeated slowmo.RunqEntry runq_entries = 3
     */
    runqEntries: RunqEntry[];
    /**
     * @generated from protobuf field: slowmo.RunqEntry runnext = 4
     */
    runnext?: RunqEntry;
}
/**
 * @generated from protobuf message slowmo.InterpretedPC
 */
export interface InterpretedPC {
    /**
     * @generated from protobuf field: optional string file = 1
     */
    file?: string;
    /**
     * @generated from protobuf field: optional int32 line = 2
     */
    line?: number;
    /**
     * @generated from protobuf field: optional string func = 3
     */
    func?: string;
}
/**
 * @generated from protobuf message slowmo.RunqEntry
 */
export interface RunqEntry {
    /**
     * @generated from protobuf field: optional int64 go_id = 1
     */
    goId?: bigint;
    /**
     * @generated from protobuf field: slowmo.InterpretedPC execution_context = 2
     */
    executionContext?: InterpretedPC;
}
/**
 * @generated from protobuf message slowmo.RuntimeOutput
 */
export interface RuntimeOutput {
    /**
     * @generated from protobuf field: optional string output = 1
     */
    output?: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class CompileAndRunRequest$Type extends MessageType<CompileAndRunRequest> {
    constructor() {
        super("slowmo.CompileAndRunRequest", [
            { no: 1, name: "source", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CompileAndRunRequest>): CompileAndRunRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CompileAndRunRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompileAndRunRequest): CompileAndRunRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string source */ 1:
                    message.source = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompileAndRunRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string source = 1; */
        if (message.source !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.source);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.CompileAndRunRequest
 */
export const CompileAndRunRequest = new CompileAndRunRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompileAndRunResponse$Type extends MessageType<CompileAndRunResponse> {
    constructor() {
        super("slowmo.CompileAndRunResponse", [
            { no: 1, name: "compile_error", kind: "message", oneof: "compileAndRunOneof", T: () => CompilationError },
            { no: 2, name: "runtime_error", kind: "message", oneof: "compileAndRunOneof", T: () => RuntimeError },
            { no: 3, name: "run_event", kind: "message", oneof: "compileAndRunOneof", T: () => ProbeEvent },
            { no: 4, name: "runtime_output", kind: "message", oneof: "compileAndRunOneof", T: () => RuntimeOutput }
        ]);
    }
    create(value?: PartialMessage<CompileAndRunResponse>): CompileAndRunResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.compileAndRunOneof = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CompileAndRunResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompileAndRunResponse): CompileAndRunResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* slowmo.CompilationError compile_error */ 1:
                    message.compileAndRunOneof = {
                        oneofKind: "compileError",
                        compileError: CompilationError.internalBinaryRead(reader, reader.uint32(), options, (message.compileAndRunOneof as any).compileError)
                    };
                    break;
                case /* slowmo.RuntimeError runtime_error */ 2:
                    message.compileAndRunOneof = {
                        oneofKind: "runtimeError",
                        runtimeError: RuntimeError.internalBinaryRead(reader, reader.uint32(), options, (message.compileAndRunOneof as any).runtimeError)
                    };
                    break;
                case /* slowmo.ProbeEvent run_event */ 3:
                    message.compileAndRunOneof = {
                        oneofKind: "runEvent",
                        runEvent: ProbeEvent.internalBinaryRead(reader, reader.uint32(), options, (message.compileAndRunOneof as any).runEvent)
                    };
                    break;
                case /* slowmo.RuntimeOutput runtime_output */ 4:
                    message.compileAndRunOneof = {
                        oneofKind: "runtimeOutput",
                        runtimeOutput: RuntimeOutput.internalBinaryRead(reader, reader.uint32(), options, (message.compileAndRunOneof as any).runtimeOutput)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompileAndRunResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* slowmo.CompilationError compile_error = 1; */
        if (message.compileAndRunOneof.oneofKind === "compileError")
            CompilationError.internalBinaryWrite(message.compileAndRunOneof.compileError, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.RuntimeError runtime_error = 2; */
        if (message.compileAndRunOneof.oneofKind === "runtimeError")
            RuntimeError.internalBinaryWrite(message.compileAndRunOneof.runtimeError, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.ProbeEvent run_event = 3; */
        if (message.compileAndRunOneof.oneofKind === "runEvent")
            ProbeEvent.internalBinaryWrite(message.compileAndRunOneof.runEvent, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.RuntimeOutput runtime_output = 4; */
        if (message.compileAndRunOneof.oneofKind === "runtimeOutput")
            RuntimeOutput.internalBinaryWrite(message.compileAndRunOneof.runtimeOutput, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.CompileAndRunResponse
 */
export const CompileAndRunResponse = new CompileAndRunResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompilationError$Type extends MessageType<CompilationError> {
    constructor() {
        super("slowmo.CompilationError", [
            { no: 1, name: "error_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CompilationError>): CompilationError {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CompilationError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompilationError): CompilationError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string error_message */ 1:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompilationError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string error_message = 1; */
        if (message.errorMessage !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.CompilationError
 */
export const CompilationError = new CompilationError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeError$Type extends MessageType<RuntimeError> {
    constructor() {
        super("slowmo.RuntimeError", [
            { no: 1, name: "error_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RuntimeError>): RuntimeError {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RuntimeError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeError): RuntimeError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string error_message */ 1:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string error_message = 1; */
        if (message.errorMessage !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.RuntimeError
 */
export const RuntimeError = new RuntimeError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProbeEvent$Type extends MessageType<ProbeEvent> {
    constructor() {
        super("slowmo.ProbeEvent", [
            { no: 1, name: "runq_status_event", kind: "message", oneof: "probeEventOneof", T: () => RunqStatusEvent }
        ]);
    }
    create(value?: PartialMessage<ProbeEvent>): ProbeEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.probeEventOneof = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ProbeEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProbeEvent): ProbeEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* slowmo.RunqStatusEvent runq_status_event */ 1:
                    message.probeEventOneof = {
                        oneofKind: "runqStatusEvent",
                        runqStatusEvent: RunqStatusEvent.internalBinaryRead(reader, reader.uint32(), options, (message.probeEventOneof as any).runqStatusEvent)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProbeEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* slowmo.RunqStatusEvent runq_status_event = 1; */
        if (message.probeEventOneof.oneofKind === "runqStatusEvent")
            RunqStatusEvent.internalBinaryWrite(message.probeEventOneof.runqStatusEvent, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.ProbeEvent
 */
export const ProbeEvent = new ProbeEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunqStatusEvent$Type extends MessageType<RunqStatusEvent> {
    constructor() {
        super("slowmo.RunqStatusEvent", [
            { no: 1, name: "proc_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "current_pc", kind: "message", T: () => InterpretedPC },
            { no: 3, name: "runq_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RunqEntry },
            { no: 4, name: "runnext", kind: "message", T: () => RunqEntry }
        ]);
    }
    create(value?: PartialMessage<RunqStatusEvent>): RunqStatusEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.runqEntries = [];
        if (value !== undefined)
            reflectionMergePartial<RunqStatusEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunqStatusEvent): RunqStatusEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 proc_id */ 1:
                    message.procId = reader.int64().toBigInt();
                    break;
                case /* slowmo.InterpretedPC current_pc */ 2:
                    message.currentPc = InterpretedPC.internalBinaryRead(reader, reader.uint32(), options, message.currentPc);
                    break;
                case /* repeated slowmo.RunqEntry runq_entries */ 3:
                    message.runqEntries.push(RunqEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* slowmo.RunqEntry runnext */ 4:
                    message.runnext = RunqEntry.internalBinaryRead(reader, reader.uint32(), options, message.runnext);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunqStatusEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 proc_id = 1; */
        if (message.procId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.procId);
        /* slowmo.InterpretedPC current_pc = 2; */
        if (message.currentPc)
            InterpretedPC.internalBinaryWrite(message.currentPc, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated slowmo.RunqEntry runq_entries = 3; */
        for (let i = 0; i < message.runqEntries.length; i++)
            RunqEntry.internalBinaryWrite(message.runqEntries[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.RunqEntry runnext = 4; */
        if (message.runnext)
            RunqEntry.internalBinaryWrite(message.runnext, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.RunqStatusEvent
 */
export const RunqStatusEvent = new RunqStatusEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InterpretedPC$Type extends MessageType<InterpretedPC> {
    constructor() {
        super("slowmo.InterpretedPC", [
            { no: 1, name: "file", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "line", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "func", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InterpretedPC>): InterpretedPC {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<InterpretedPC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InterpretedPC): InterpretedPC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string file */ 1:
                    message.file = reader.string();
                    break;
                case /* optional int32 line */ 2:
                    message.line = reader.int32();
                    break;
                case /* optional string func */ 3:
                    message.func = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InterpretedPC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string file = 1; */
        if (message.file !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.file);
        /* optional int32 line = 2; */
        if (message.line !== undefined)
            writer.tag(2, WireType.Varint).int32(message.line);
        /* optional string func = 3; */
        if (message.func !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.func);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.InterpretedPC
 */
export const InterpretedPC = new InterpretedPC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunqEntry$Type extends MessageType<RunqEntry> {
    constructor() {
        super("slowmo.RunqEntry", [
            { no: 1, name: "go_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "execution_context", kind: "message", T: () => InterpretedPC }
        ]);
    }
    create(value?: PartialMessage<RunqEntry>): RunqEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RunqEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunqEntry): RunqEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 go_id */ 1:
                    message.goId = reader.int64().toBigInt();
                    break;
                case /* slowmo.InterpretedPC execution_context */ 2:
                    message.executionContext = InterpretedPC.internalBinaryRead(reader, reader.uint32(), options, message.executionContext);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunqEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 go_id = 1; */
        if (message.goId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.goId);
        /* slowmo.InterpretedPC execution_context = 2; */
        if (message.executionContext)
            InterpretedPC.internalBinaryWrite(message.executionContext, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.RunqEntry
 */
export const RunqEntry = new RunqEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeOutput$Type extends MessageType<RuntimeOutput> {
    constructor() {
        super("slowmo.RuntimeOutput", [
            { no: 1, name: "output", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RuntimeOutput>): RuntimeOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RuntimeOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeOutput): RuntimeOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string output */ 1:
                    message.output = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string output = 1; */
        if (message.output !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.output);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.RuntimeOutput
 */
export const RuntimeOutput = new RuntimeOutput$Type();
/**
 * @generated ServiceType for protobuf service slowmo.SlowmoService
 */
export const SlowmoService = new ServiceType("slowmo.SlowmoService", [
    { name: "CompileAndRun", serverStreaming: true, options: {}, I: CompileAndRunRequest, O: CompileAndRunResponse }
]);
