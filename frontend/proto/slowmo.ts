// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "slowmo.proto" (package "slowmo", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message slowmo.CompileAndRunRequest
 */
export interface CompileAndRunRequest {
    /**
     * @generated from protobuf field: optional string source = 1
     */
    source?: string; // Go source code from user.
    /**
     * @generated from protobuf field: optional string go_version = 2
     */
    goVersion?: string;
}
/**
 * @generated from protobuf message slowmo.CompileAndRunResponse
 */
export interface CompileAndRunResponse {
    /**
     * @generated from protobuf oneof: compile_and_run_oneof
     */
    compileAndRunOneof: {
        oneofKind: "compileError";
        /**
         * @generated from protobuf field: slowmo.CompilationError compile_error = 1
         */
        compileError: CompilationError;
    } | {
        oneofKind: "runtimeResult";
        /**
         * @generated from protobuf field: slowmo.RuntimeResult runtime_result = 2
         */
        runtimeResult: RuntimeResult;
    } | {
        oneofKind: "runEvent";
        /**
         * @generated from protobuf field: slowmo.ProbeEvent run_event = 3
         */
        runEvent: ProbeEvent;
    } | {
        oneofKind: "runtimeOutput";
        /**
         * @generated from protobuf field: slowmo.RuntimeOutput runtime_output = 4
         */
        runtimeOutput: RuntimeOutput;
    } | {
        oneofKind: "gomaxprocs";
        /**
         * @generated from protobuf field: int32 gomaxprocs = 5
         */
        gomaxprocs: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message slowmo.CompilationError
 */
export interface CompilationError {
    /**
     * @generated from protobuf field: optional string error_message = 1
     */
    errorMessage?: string;
}
/**
 * @generated from protobuf message slowmo.RuntimeResult
 */
export interface RuntimeResult {
    /**
     * @generated from protobuf field: optional string error_message = 1
     */
    errorMessage?: string;
}
/**
 * @generated from protobuf message slowmo.RuntimeOutput
 */
export interface RuntimeOutput {
    /**
     * @generated from protobuf field: optional string output = 1
     */
    output?: string;
}
/**
 * @generated from protobuf message slowmo.ProbeEvent
 */
export interface ProbeEvent {
    /**
     * @generated from protobuf oneof: probe_event_oneof
     */
    probeEventOneof: {
        oneofKind: "delayEvent";
        /**
         * RunqStatusEvent runq_status_event = 1 [deprecated=true];
         *
         * @generated from protobuf field: slowmo.DelayEvent delay_event = 2
         */
        delayEvent: DelayEvent; // ScheduleEvent schedule_event = 3 [deprecated=true];
    } | {
        oneofKind: "notificationEvent";
        /**
         * @generated from protobuf field: slowmo.NotificationEvent notification_event = 4
         */
        notificationEvent: NotificationEvent;
    } | {
        oneofKind: "structureStateEvent";
        /**
         * @generated from protobuf field: slowmo.StructureStateEvent structure_state_event = 5
         */
        structureStateEvent: StructureStateEvent;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message slowmo.NotificationEvent
 */
export interface NotificationEvent {
    /**
     * @generated from protobuf oneof: notification_oneof
     */
    notificationOneof: {
        oneofKind: "scheduleEvent";
        /**
         * DelayEvent delay_event = 1 [deprecated=true];
         *
         * @generated from protobuf field: slowmo.ScheduleEvent schedule_event = 2
         */
        scheduleEvent: ScheduleEvent;
    } | {
        oneofKind: "newProcEvent";
        /**
         * @generated from protobuf field: slowmo.NewProcEvent new_proc_event = 3
         */
        newProcEvent: NewProcEvent;
    } | {
        oneofKind: "goparkEvent";
        /**
         * @generated from protobuf field: slowmo.GoparkEvent gopark_event = 4
         */
        goparkEvent: GoparkEvent;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message slowmo.StructureStateEvent
 */
export interface StructureStateEvent {
    /**
     * @generated from protobuf oneof: structure_state_oneof
     */
    structureStateOneof: {
        oneofKind: "runqStatusEvent";
        /**
         * @generated from protobuf field: slowmo.RunqStatusEvent runq_status_event = 1
         */
        runqStatusEvent: RunqStatusEvent;
    } | {
        oneofKind: "executeEvent";
        /**
         * @generated from protobuf field: slowmo.ExecuteEvent execute_event = 2
         */
        executeEvent: ExecuteEvent;
    } | {
        oneofKind: "goreadyEvent";
        /**
         * @generated from protobuf field: slowmo.GoreadyEvent goready_event = 3
         */
        goreadyEvent: GoreadyEvent;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message slowmo.RunqStatusEvent
 */
export interface RunqStatusEvent {
    /**
     * @generated from protobuf field: optional int64 proc_id = 1
     */
    procId?: bigint;
    /**
     * @generated from protobuf field: repeated slowmo.RunqEntry runq_entries = 3
     */
    runqEntries: RunqEntry[];
    /**
     * @generated from protobuf field: slowmo.RunqEntry runnext = 4
     */
    runnext?: RunqEntry;
    /**
     * @generated from protobuf field: optional int64 m_id = 5
     */
    mId?: bigint;
}
/**
 * @generated from protobuf message slowmo.RunqEntry
 */
export interface RunqEntry {
    /**
     * @generated from protobuf field: optional int64 go_id = 1
     */
    goId?: bigint;
    /**
     * @generated from protobuf field: slowmo.InterpretedPC execution_context = 2
     */
    executionContext?: InterpretedPC;
}
/**
 * @generated from protobuf message slowmo.InterpretedPC
 */
export interface InterpretedPC {
    /**
     * @generated from protobuf field: optional string file = 1
     */
    file?: string;
    /**
     * @generated from protobuf field: optional int32 line = 2
     */
    line?: number;
    /**
     * @generated from protobuf field: optional string func = 3
     */
    func?: string;
}
/**
 * @generated from protobuf message slowmo.ExecuteEvent
 */
export interface ExecuteEvent {
    /**
     * @generated from protobuf field: optional int64 m_id = 1
     */
    mId?: bigint;
    /**
     * @generated from protobuf field: slowmo.RunqEntry found = 2
     */
    found?: RunqEntry;
    /**
     * @generated from protobuf field: optional int64 proc_id = 3
     */
    procId?: bigint;
    /**
     * @generated from protobuf field: repeated slowmo.RunqStatusEvent runqs = 4
     */
    runqs: RunqStatusEvent[];
}
/**
 * @generated from protobuf message slowmo.DelayEvent
 */
export interface DelayEvent {
    /**
     * @generated from protobuf field: optional int64 m_id = 1
     */
    mId?: bigint;
    /**
     * @generated from protobuf field: optional int64 go_id = 2
     */
    goId?: bigint;
    /**
     * @generated from protobuf field: slowmo.InterpretedPC current_pc = 3
     */
    currentPc?: InterpretedPC;
}
/**
 * @generated from protobuf message slowmo.ScheduleEvent
 */
export interface ScheduleEvent {
    /**
     * @generated from protobuf field: optional int64 m_id = 1
     */
    mId?: bigint;
    /**
     * @generated from protobuf field: slowmo.ScheduleReason reason = 2
     */
    reason: ScheduleReason;
    /**
     * @generated from protobuf field: optional int64 proc_id = 3
     */
    procId?: bigint;
}
/**
 * @generated from protobuf message slowmo.NewProcEvent
 */
export interface NewProcEvent {
    /**
     * @generated from protobuf field: optional int64 creator_go_id = 1
     */
    creatorGoId?: bigint;
    /**
     * @generated from protobuf field: slowmo.InterpretedPC start_pc = 2
     */
    startPc?: InterpretedPC;
    /**
     * @generated from protobuf field: optional int64 m_id = 3
     */
    mId?: bigint;
}
/**
 * @generated from protobuf message slowmo.GoparkEvent
 */
export interface GoparkEvent {
    /**
     * @generated from protobuf field: optional int64 m_id = 1
     */
    mId?: bigint;
    /**
     * @generated from protobuf field: slowmo.RunqEntry parked = 2
     */
    parked?: RunqEntry;
    /**
     * @generated from protobuf field: optional string wait_reason = 3
     */
    waitReason?: string;
}
/**
 * @generated from protobuf message slowmo.GoreadyEvent
 */
export interface GoreadyEvent {
    /**
     * @generated from protobuf field: optional int64 m_id = 1
     */
    mId?: bigint;
    /**
     * @generated from protobuf field: optional int64 go_id = 2
     */
    goId?: bigint;
    /**
     * @generated from protobuf field: slowmo.RunqStatusEvent runq = 3
     */
    runq?: RunqStatusEvent;
}
/**
 * @generated from protobuf message slowmo.AuthnRequest
 */
export interface AuthnRequest {
    /**
     * @generated from protobuf field: slowmo.AuthnParams params = 1
     */
    params?: AuthnParams;
}
/**
 * @generated from protobuf message slowmo.AuthnParams
 */
export interface AuthnParams {
    /**
     * @generated from protobuf field: optional string code = 1
     */
    code?: string;
    /**
     * @generated from protobuf field: optional string state = 2
     */
    state?: string;
    /**
     * @generated from protobuf field: slowmo.AuthnChannel channel = 3
     */
    channel: AuthnChannel;
}
/**
 * @generated from protobuf message slowmo.AuthnResponse
 */
export interface AuthnResponse {
    /**
     * @generated from protobuf field: optional string state = 1
     */
    state?: string;
}
/**
 * @generated from protobuf enum slowmo.ScheduleReason
 */
export enum ScheduleReason {
    /**
     * @generated from protobuf enum value: GOEXIT = 0;
     */
    GOEXIT = 0,
    /**
     * @generated from protobuf enum value: GOPARK = 1;
     */
    GOPARK = 1,
    /**
     * @generated from protobuf enum value: MSTART = 2;
     */
    MSTART = 2,
    /**
     * @generated from protobuf enum value: OTHER = 20;
     */
    OTHER = 20
}
/**
 * @generated from protobuf enum slowmo.AuthnChannel
 */
export enum AuthnChannel {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: GITHUB = 1;
     */
    GITHUB = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class CompileAndRunRequest$Type extends MessageType<CompileAndRunRequest> {
    constructor() {
        super("slowmo.CompileAndRunRequest", [
            { no: 1, name: "source", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "go_version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CompileAndRunRequest>): CompileAndRunRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CompileAndRunRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompileAndRunRequest): CompileAndRunRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string source */ 1:
                    message.source = reader.string();
                    break;
                case /* optional string go_version */ 2:
                    message.goVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompileAndRunRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string source = 1; */
        if (message.source !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.source);
        /* optional string go_version = 2; */
        if (message.goVersion !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.goVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.CompileAndRunRequest
 */
export const CompileAndRunRequest = new CompileAndRunRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompileAndRunResponse$Type extends MessageType<CompileAndRunResponse> {
    constructor() {
        super("slowmo.CompileAndRunResponse", [
            { no: 1, name: "compile_error", kind: "message", oneof: "compileAndRunOneof", T: () => CompilationError },
            { no: 2, name: "runtime_result", kind: "message", oneof: "compileAndRunOneof", T: () => RuntimeResult },
            { no: 3, name: "run_event", kind: "message", oneof: "compileAndRunOneof", T: () => ProbeEvent },
            { no: 4, name: "runtime_output", kind: "message", oneof: "compileAndRunOneof", T: () => RuntimeOutput },
            { no: 5, name: "gomaxprocs", kind: "scalar", oneof: "compileAndRunOneof", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CompileAndRunResponse>): CompileAndRunResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.compileAndRunOneof = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CompileAndRunResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompileAndRunResponse): CompileAndRunResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* slowmo.CompilationError compile_error */ 1:
                    message.compileAndRunOneof = {
                        oneofKind: "compileError",
                        compileError: CompilationError.internalBinaryRead(reader, reader.uint32(), options, (message.compileAndRunOneof as any).compileError)
                    };
                    break;
                case /* slowmo.RuntimeResult runtime_result */ 2:
                    message.compileAndRunOneof = {
                        oneofKind: "runtimeResult",
                        runtimeResult: RuntimeResult.internalBinaryRead(reader, reader.uint32(), options, (message.compileAndRunOneof as any).runtimeResult)
                    };
                    break;
                case /* slowmo.ProbeEvent run_event */ 3:
                    message.compileAndRunOneof = {
                        oneofKind: "runEvent",
                        runEvent: ProbeEvent.internalBinaryRead(reader, reader.uint32(), options, (message.compileAndRunOneof as any).runEvent)
                    };
                    break;
                case /* slowmo.RuntimeOutput runtime_output */ 4:
                    message.compileAndRunOneof = {
                        oneofKind: "runtimeOutput",
                        runtimeOutput: RuntimeOutput.internalBinaryRead(reader, reader.uint32(), options, (message.compileAndRunOneof as any).runtimeOutput)
                    };
                    break;
                case /* int32 gomaxprocs */ 5:
                    message.compileAndRunOneof = {
                        oneofKind: "gomaxprocs",
                        gomaxprocs: reader.int32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompileAndRunResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* slowmo.CompilationError compile_error = 1; */
        if (message.compileAndRunOneof.oneofKind === "compileError")
            CompilationError.internalBinaryWrite(message.compileAndRunOneof.compileError, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.RuntimeResult runtime_result = 2; */
        if (message.compileAndRunOneof.oneofKind === "runtimeResult")
            RuntimeResult.internalBinaryWrite(message.compileAndRunOneof.runtimeResult, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.ProbeEvent run_event = 3; */
        if (message.compileAndRunOneof.oneofKind === "runEvent")
            ProbeEvent.internalBinaryWrite(message.compileAndRunOneof.runEvent, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.RuntimeOutput runtime_output = 4; */
        if (message.compileAndRunOneof.oneofKind === "runtimeOutput")
            RuntimeOutput.internalBinaryWrite(message.compileAndRunOneof.runtimeOutput, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 gomaxprocs = 5; */
        if (message.compileAndRunOneof.oneofKind === "gomaxprocs")
            writer.tag(5, WireType.Varint).int32(message.compileAndRunOneof.gomaxprocs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.CompileAndRunResponse
 */
export const CompileAndRunResponse = new CompileAndRunResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompilationError$Type extends MessageType<CompilationError> {
    constructor() {
        super("slowmo.CompilationError", [
            { no: 1, name: "error_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CompilationError>): CompilationError {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CompilationError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompilationError): CompilationError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string error_message */ 1:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompilationError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string error_message = 1; */
        if (message.errorMessage !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.CompilationError
 */
export const CompilationError = new CompilationError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeResult$Type extends MessageType<RuntimeResult> {
    constructor() {
        super("slowmo.RuntimeResult", [
            { no: 1, name: "error_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RuntimeResult>): RuntimeResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RuntimeResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeResult): RuntimeResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string error_message */ 1:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string error_message = 1; */
        if (message.errorMessage !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.RuntimeResult
 */
export const RuntimeResult = new RuntimeResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeOutput$Type extends MessageType<RuntimeOutput> {
    constructor() {
        super("slowmo.RuntimeOutput", [
            { no: 1, name: "output", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RuntimeOutput>): RuntimeOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RuntimeOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeOutput): RuntimeOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string output */ 1:
                    message.output = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string output = 1; */
        if (message.output !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.output);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.RuntimeOutput
 */
export const RuntimeOutput = new RuntimeOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProbeEvent$Type extends MessageType<ProbeEvent> {
    constructor() {
        super("slowmo.ProbeEvent", [
            { no: 2, name: "delay_event", kind: "message", oneof: "probeEventOneof", T: () => DelayEvent },
            { no: 4, name: "notification_event", kind: "message", oneof: "probeEventOneof", T: () => NotificationEvent },
            { no: 5, name: "structure_state_event", kind: "message", oneof: "probeEventOneof", T: () => StructureStateEvent }
        ]);
    }
    create(value?: PartialMessage<ProbeEvent>): ProbeEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.probeEventOneof = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ProbeEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProbeEvent): ProbeEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* slowmo.DelayEvent delay_event */ 2:
                    message.probeEventOneof = {
                        oneofKind: "delayEvent",
                        delayEvent: DelayEvent.internalBinaryRead(reader, reader.uint32(), options, (message.probeEventOneof as any).delayEvent)
                    };
                    break;
                case /* slowmo.NotificationEvent notification_event */ 4:
                    message.probeEventOneof = {
                        oneofKind: "notificationEvent",
                        notificationEvent: NotificationEvent.internalBinaryRead(reader, reader.uint32(), options, (message.probeEventOneof as any).notificationEvent)
                    };
                    break;
                case /* slowmo.StructureStateEvent structure_state_event */ 5:
                    message.probeEventOneof = {
                        oneofKind: "structureStateEvent",
                        structureStateEvent: StructureStateEvent.internalBinaryRead(reader, reader.uint32(), options, (message.probeEventOneof as any).structureStateEvent)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProbeEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* slowmo.DelayEvent delay_event = 2; */
        if (message.probeEventOneof.oneofKind === "delayEvent")
            DelayEvent.internalBinaryWrite(message.probeEventOneof.delayEvent, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.NotificationEvent notification_event = 4; */
        if (message.probeEventOneof.oneofKind === "notificationEvent")
            NotificationEvent.internalBinaryWrite(message.probeEventOneof.notificationEvent, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.StructureStateEvent structure_state_event = 5; */
        if (message.probeEventOneof.oneofKind === "structureStateEvent")
            StructureStateEvent.internalBinaryWrite(message.probeEventOneof.structureStateEvent, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.ProbeEvent
 */
export const ProbeEvent = new ProbeEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NotificationEvent$Type extends MessageType<NotificationEvent> {
    constructor() {
        super("slowmo.NotificationEvent", [
            { no: 2, name: "schedule_event", kind: "message", oneof: "notificationOneof", T: () => ScheduleEvent },
            { no: 3, name: "new_proc_event", kind: "message", oneof: "notificationOneof", T: () => NewProcEvent },
            { no: 4, name: "gopark_event", kind: "message", oneof: "notificationOneof", T: () => GoparkEvent }
        ]);
    }
    create(value?: PartialMessage<NotificationEvent>): NotificationEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.notificationOneof = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<NotificationEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NotificationEvent): NotificationEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* slowmo.ScheduleEvent schedule_event */ 2:
                    message.notificationOneof = {
                        oneofKind: "scheduleEvent",
                        scheduleEvent: ScheduleEvent.internalBinaryRead(reader, reader.uint32(), options, (message.notificationOneof as any).scheduleEvent)
                    };
                    break;
                case /* slowmo.NewProcEvent new_proc_event */ 3:
                    message.notificationOneof = {
                        oneofKind: "newProcEvent",
                        newProcEvent: NewProcEvent.internalBinaryRead(reader, reader.uint32(), options, (message.notificationOneof as any).newProcEvent)
                    };
                    break;
                case /* slowmo.GoparkEvent gopark_event */ 4:
                    message.notificationOneof = {
                        oneofKind: "goparkEvent",
                        goparkEvent: GoparkEvent.internalBinaryRead(reader, reader.uint32(), options, (message.notificationOneof as any).goparkEvent)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NotificationEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* slowmo.ScheduleEvent schedule_event = 2; */
        if (message.notificationOneof.oneofKind === "scheduleEvent")
            ScheduleEvent.internalBinaryWrite(message.notificationOneof.scheduleEvent, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.NewProcEvent new_proc_event = 3; */
        if (message.notificationOneof.oneofKind === "newProcEvent")
            NewProcEvent.internalBinaryWrite(message.notificationOneof.newProcEvent, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.GoparkEvent gopark_event = 4; */
        if (message.notificationOneof.oneofKind === "goparkEvent")
            GoparkEvent.internalBinaryWrite(message.notificationOneof.goparkEvent, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.NotificationEvent
 */
export const NotificationEvent = new NotificationEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StructureStateEvent$Type extends MessageType<StructureStateEvent> {
    constructor() {
        super("slowmo.StructureStateEvent", [
            { no: 1, name: "runq_status_event", kind: "message", oneof: "structureStateOneof", T: () => RunqStatusEvent },
            { no: 2, name: "execute_event", kind: "message", oneof: "structureStateOneof", T: () => ExecuteEvent },
            { no: 3, name: "goready_event", kind: "message", oneof: "structureStateOneof", T: () => GoreadyEvent }
        ]);
    }
    create(value?: PartialMessage<StructureStateEvent>): StructureStateEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.structureStateOneof = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<StructureStateEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StructureStateEvent): StructureStateEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* slowmo.RunqStatusEvent runq_status_event */ 1:
                    message.structureStateOneof = {
                        oneofKind: "runqStatusEvent",
                        runqStatusEvent: RunqStatusEvent.internalBinaryRead(reader, reader.uint32(), options, (message.structureStateOneof as any).runqStatusEvent)
                    };
                    break;
                case /* slowmo.ExecuteEvent execute_event */ 2:
                    message.structureStateOneof = {
                        oneofKind: "executeEvent",
                        executeEvent: ExecuteEvent.internalBinaryRead(reader, reader.uint32(), options, (message.structureStateOneof as any).executeEvent)
                    };
                    break;
                case /* slowmo.GoreadyEvent goready_event */ 3:
                    message.structureStateOneof = {
                        oneofKind: "goreadyEvent",
                        goreadyEvent: GoreadyEvent.internalBinaryRead(reader, reader.uint32(), options, (message.structureStateOneof as any).goreadyEvent)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StructureStateEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* slowmo.RunqStatusEvent runq_status_event = 1; */
        if (message.structureStateOneof.oneofKind === "runqStatusEvent")
            RunqStatusEvent.internalBinaryWrite(message.structureStateOneof.runqStatusEvent, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.ExecuteEvent execute_event = 2; */
        if (message.structureStateOneof.oneofKind === "executeEvent")
            ExecuteEvent.internalBinaryWrite(message.structureStateOneof.executeEvent, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.GoreadyEvent goready_event = 3; */
        if (message.structureStateOneof.oneofKind === "goreadyEvent")
            GoreadyEvent.internalBinaryWrite(message.structureStateOneof.goreadyEvent, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.StructureStateEvent
 */
export const StructureStateEvent = new StructureStateEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunqStatusEvent$Type extends MessageType<RunqStatusEvent> {
    constructor() {
        super("slowmo.RunqStatusEvent", [
            { no: 1, name: "proc_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "runq_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RunqEntry },
            { no: 4, name: "runnext", kind: "message", T: () => RunqEntry },
            { no: 5, name: "m_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RunqStatusEvent>): RunqStatusEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.runqEntries = [];
        if (value !== undefined)
            reflectionMergePartial<RunqStatusEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunqStatusEvent): RunqStatusEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 proc_id */ 1:
                    message.procId = reader.int64().toBigInt();
                    break;
                case /* repeated slowmo.RunqEntry runq_entries */ 3:
                    message.runqEntries.push(RunqEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* slowmo.RunqEntry runnext */ 4:
                    message.runnext = RunqEntry.internalBinaryRead(reader, reader.uint32(), options, message.runnext);
                    break;
                case /* optional int64 m_id */ 5:
                    message.mId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunqStatusEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 proc_id = 1; */
        if (message.procId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.procId);
        /* repeated slowmo.RunqEntry runq_entries = 3; */
        for (let i = 0; i < message.runqEntries.length; i++)
            RunqEntry.internalBinaryWrite(message.runqEntries[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* slowmo.RunqEntry runnext = 4; */
        if (message.runnext)
            RunqEntry.internalBinaryWrite(message.runnext, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional int64 m_id = 5; */
        if (message.mId !== undefined)
            writer.tag(5, WireType.Varint).int64(message.mId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.RunqStatusEvent
 */
export const RunqStatusEvent = new RunqStatusEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunqEntry$Type extends MessageType<RunqEntry> {
    constructor() {
        super("slowmo.RunqEntry", [
            { no: 1, name: "go_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "execution_context", kind: "message", T: () => InterpretedPC }
        ]);
    }
    create(value?: PartialMessage<RunqEntry>): RunqEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RunqEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunqEntry): RunqEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 go_id */ 1:
                    message.goId = reader.int64().toBigInt();
                    break;
                case /* slowmo.InterpretedPC execution_context */ 2:
                    message.executionContext = InterpretedPC.internalBinaryRead(reader, reader.uint32(), options, message.executionContext);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunqEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 go_id = 1; */
        if (message.goId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.goId);
        /* slowmo.InterpretedPC execution_context = 2; */
        if (message.executionContext)
            InterpretedPC.internalBinaryWrite(message.executionContext, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.RunqEntry
 */
export const RunqEntry = new RunqEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InterpretedPC$Type extends MessageType<InterpretedPC> {
    constructor() {
        super("slowmo.InterpretedPC", [
            { no: 1, name: "file", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "line", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "func", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InterpretedPC>): InterpretedPC {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<InterpretedPC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InterpretedPC): InterpretedPC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string file */ 1:
                    message.file = reader.string();
                    break;
                case /* optional int32 line */ 2:
                    message.line = reader.int32();
                    break;
                case /* optional string func */ 3:
                    message.func = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InterpretedPC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string file = 1; */
        if (message.file !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.file);
        /* optional int32 line = 2; */
        if (message.line !== undefined)
            writer.tag(2, WireType.Varint).int32(message.line);
        /* optional string func = 3; */
        if (message.func !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.func);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.InterpretedPC
 */
export const InterpretedPC = new InterpretedPC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteEvent$Type extends MessageType<ExecuteEvent> {
    constructor() {
        super("slowmo.ExecuteEvent", [
            { no: 1, name: "m_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "found", kind: "message", T: () => RunqEntry },
            { no: 3, name: "proc_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "runqs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RunqStatusEvent }
        ]);
    }
    create(value?: PartialMessage<ExecuteEvent>): ExecuteEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.runqs = [];
        if (value !== undefined)
            reflectionMergePartial<ExecuteEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteEvent): ExecuteEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 m_id */ 1:
                    message.mId = reader.int64().toBigInt();
                    break;
                case /* slowmo.RunqEntry found */ 2:
                    message.found = RunqEntry.internalBinaryRead(reader, reader.uint32(), options, message.found);
                    break;
                case /* optional int64 proc_id */ 3:
                    message.procId = reader.int64().toBigInt();
                    break;
                case /* repeated slowmo.RunqStatusEvent runqs */ 4:
                    message.runqs.push(RunqStatusEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 m_id = 1; */
        if (message.mId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.mId);
        /* slowmo.RunqEntry found = 2; */
        if (message.found)
            RunqEntry.internalBinaryWrite(message.found, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int64 proc_id = 3; */
        if (message.procId !== undefined)
            writer.tag(3, WireType.Varint).int64(message.procId);
        /* repeated slowmo.RunqStatusEvent runqs = 4; */
        for (let i = 0; i < message.runqs.length; i++)
            RunqStatusEvent.internalBinaryWrite(message.runqs[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.ExecuteEvent
 */
export const ExecuteEvent = new ExecuteEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DelayEvent$Type extends MessageType<DelayEvent> {
    constructor() {
        super("slowmo.DelayEvent", [
            { no: 1, name: "m_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "go_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "current_pc", kind: "message", T: () => InterpretedPC }
        ]);
    }
    create(value?: PartialMessage<DelayEvent>): DelayEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DelayEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DelayEvent): DelayEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 m_id */ 1:
                    message.mId = reader.int64().toBigInt();
                    break;
                case /* optional int64 go_id */ 2:
                    message.goId = reader.int64().toBigInt();
                    break;
                case /* slowmo.InterpretedPC current_pc */ 3:
                    message.currentPc = InterpretedPC.internalBinaryRead(reader, reader.uint32(), options, message.currentPc);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DelayEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 m_id = 1; */
        if (message.mId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.mId);
        /* optional int64 go_id = 2; */
        if (message.goId !== undefined)
            writer.tag(2, WireType.Varint).int64(message.goId);
        /* slowmo.InterpretedPC current_pc = 3; */
        if (message.currentPc)
            InterpretedPC.internalBinaryWrite(message.currentPc, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.DelayEvent
 */
export const DelayEvent = new DelayEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScheduleEvent$Type extends MessageType<ScheduleEvent> {
    constructor() {
        super("slowmo.ScheduleEvent", [
            { no: 1, name: "m_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "reason", kind: "enum", T: () => ["slowmo.ScheduleReason", ScheduleReason] },
            { no: 3, name: "proc_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ScheduleEvent>): ScheduleEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = 0;
        if (value !== undefined)
            reflectionMergePartial<ScheduleEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScheduleEvent): ScheduleEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 m_id */ 1:
                    message.mId = reader.int64().toBigInt();
                    break;
                case /* slowmo.ScheduleReason reason */ 2:
                    message.reason = reader.int32();
                    break;
                case /* optional int64 proc_id */ 3:
                    message.procId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScheduleEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 m_id = 1; */
        if (message.mId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.mId);
        /* slowmo.ScheduleReason reason = 2; */
        if (message.reason !== 0)
            writer.tag(2, WireType.Varint).int32(message.reason);
        /* optional int64 proc_id = 3; */
        if (message.procId !== undefined)
            writer.tag(3, WireType.Varint).int64(message.procId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.ScheduleEvent
 */
export const ScheduleEvent = new ScheduleEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewProcEvent$Type extends MessageType<NewProcEvent> {
    constructor() {
        super("slowmo.NewProcEvent", [
            { no: 1, name: "creator_go_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "start_pc", kind: "message", T: () => InterpretedPC },
            { no: 3, name: "m_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<NewProcEvent>): NewProcEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<NewProcEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewProcEvent): NewProcEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 creator_go_id */ 1:
                    message.creatorGoId = reader.int64().toBigInt();
                    break;
                case /* slowmo.InterpretedPC start_pc */ 2:
                    message.startPc = InterpretedPC.internalBinaryRead(reader, reader.uint32(), options, message.startPc);
                    break;
                case /* optional int64 m_id */ 3:
                    message.mId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewProcEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 creator_go_id = 1; */
        if (message.creatorGoId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.creatorGoId);
        /* slowmo.InterpretedPC start_pc = 2; */
        if (message.startPc)
            InterpretedPC.internalBinaryWrite(message.startPc, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int64 m_id = 3; */
        if (message.mId !== undefined)
            writer.tag(3, WireType.Varint).int64(message.mId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.NewProcEvent
 */
export const NewProcEvent = new NewProcEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GoparkEvent$Type extends MessageType<GoparkEvent> {
    constructor() {
        super("slowmo.GoparkEvent", [
            { no: 1, name: "m_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "parked", kind: "message", T: () => RunqEntry },
            { no: 3, name: "wait_reason", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GoparkEvent>): GoparkEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GoparkEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GoparkEvent): GoparkEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 m_id */ 1:
                    message.mId = reader.int64().toBigInt();
                    break;
                case /* slowmo.RunqEntry parked */ 2:
                    message.parked = RunqEntry.internalBinaryRead(reader, reader.uint32(), options, message.parked);
                    break;
                case /* optional string wait_reason */ 3:
                    message.waitReason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GoparkEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 m_id = 1; */
        if (message.mId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.mId);
        /* slowmo.RunqEntry parked = 2; */
        if (message.parked)
            RunqEntry.internalBinaryWrite(message.parked, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional string wait_reason = 3; */
        if (message.waitReason !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.waitReason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.GoparkEvent
 */
export const GoparkEvent = new GoparkEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GoreadyEvent$Type extends MessageType<GoreadyEvent> {
    constructor() {
        super("slowmo.GoreadyEvent", [
            { no: 1, name: "m_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "go_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "runq", kind: "message", T: () => RunqStatusEvent }
        ]);
    }
    create(value?: PartialMessage<GoreadyEvent>): GoreadyEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GoreadyEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GoreadyEvent): GoreadyEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 m_id */ 1:
                    message.mId = reader.int64().toBigInt();
                    break;
                case /* optional int64 go_id */ 2:
                    message.goId = reader.int64().toBigInt();
                    break;
                case /* slowmo.RunqStatusEvent runq */ 3:
                    message.runq = RunqStatusEvent.internalBinaryRead(reader, reader.uint32(), options, message.runq);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GoreadyEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 m_id = 1; */
        if (message.mId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.mId);
        /* optional int64 go_id = 2; */
        if (message.goId !== undefined)
            writer.tag(2, WireType.Varint).int64(message.goId);
        /* slowmo.RunqStatusEvent runq = 3; */
        if (message.runq)
            RunqStatusEvent.internalBinaryWrite(message.runq, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.GoreadyEvent
 */
export const GoreadyEvent = new GoreadyEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthnRequest$Type extends MessageType<AuthnRequest> {
    constructor() {
        super("slowmo.AuthnRequest", [
            { no: 1, name: "params", kind: "message", T: () => AuthnParams }
        ]);
    }
    create(value?: PartialMessage<AuthnRequest>): AuthnRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AuthnRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthnRequest): AuthnRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* slowmo.AuthnParams params */ 1:
                    message.params = AuthnParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthnRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* slowmo.AuthnParams params = 1; */
        if (message.params)
            AuthnParams.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.AuthnRequest
 */
export const AuthnRequest = new AuthnRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthnParams$Type extends MessageType<AuthnParams> {
    constructor() {
        super("slowmo.AuthnParams", [
            { no: 1, name: "code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "channel", kind: "enum", T: () => ["slowmo.AuthnChannel", AuthnChannel] }
        ]);
    }
    create(value?: PartialMessage<AuthnParams>): AuthnParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.channel = 0;
        if (value !== undefined)
            reflectionMergePartial<AuthnParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthnParams): AuthnParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string code */ 1:
                    message.code = reader.string();
                    break;
                case /* optional string state */ 2:
                    message.state = reader.string();
                    break;
                case /* slowmo.AuthnChannel channel */ 3:
                    message.channel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthnParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string code = 1; */
        if (message.code !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* optional string state = 2; */
        if (message.state !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.state);
        /* slowmo.AuthnChannel channel = 3; */
        if (message.channel !== 0)
            writer.tag(3, WireType.Varint).int32(message.channel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.AuthnParams
 */
export const AuthnParams = new AuthnParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthnResponse$Type extends MessageType<AuthnResponse> {
    constructor() {
        super("slowmo.AuthnResponse", [
            { no: 1, name: "state", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthnResponse>): AuthnResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AuthnResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthnResponse): AuthnResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string state */ 1:
                    message.state = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthnResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string state = 1; */
        if (message.state !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message slowmo.AuthnResponse
 */
export const AuthnResponse = new AuthnResponse$Type();
/**
 * @generated ServiceType for protobuf service slowmo.SlowmoService
 */
export const SlowmoService = new ServiceType("slowmo.SlowmoService", [
    { name: "CompileAndRun", serverStreaming: true, options: {}, I: CompileAndRunRequest, O: CompileAndRunResponse },
    { name: "Authn", options: {}, I: AuthnRequest, O: AuthnResponse }
]);
