syntax = "proto3";
package slowmo;
option go_package = "github.com/kailun2047/slowmo/proto";

message CompileAndRunRequest {
    optional string source = 1; // Go source code from user.
}

message CompileAndRunResponse {
    oneof compile_and_run_oneof {
        CompilationError compile_error = 1;
        RuntimeError runtime_error = 2;
        ProbeEvent run_event = 3;
        RuntimeOutput runtime_output = 4;
        int32 num_cpu = 5;
    };
}

message CompilationError  {
    optional string error_message = 1;
}

message RuntimeError {
    optional string error_message = 1;
}

message RuntimeOutput {
    optional string output = 1;
}

message ProbeEvent {
    oneof probe_event_oneof {
        // RunqStatusEvent runq_status_event = 1 [deprecated=true];
        DelayEvent delay_event = 2;
        // ScheduleEvent schedule_event = 3 [deprecated=true];

        // TODO: remove redundant m_id field and use only m_id field in
        // involved_structures.
        NotificationEvent notification_event = 4;
        StructureStateEvent structure_state_event = 5;
    };
}

message NotificationEvent {
    oneof notification_oneof {
        DelayEvent delay_event = 1 [deprecated=true];
        ScheduleEvent schedule_event = 2;
        NewProcEvent new_proc_event = 3;
    }
    // One NotificationEvent may involve multiple structures.
    repeated StructureId involved_structures = 20;
}

message StructureStateEvent {
    oneof structure_state_oneof {
        RunqStatusEvent runq_status_event = 1;
        ExecuteEvent execute_event = 2;
    }
    // Technically, a StructureStateEvent may involve only one structure. But
    // make StructureId a repeated field in case we need to deal with
    // concurrently reported structures (e.g. global structures like semtable,
    // same local runqs reported for multiple schedule events on different
    // threads).
    repeated StructureId involved_structures = 20;
}

message RunqStatusEvent {
    optional int64 proc_id = 1;
    repeated RunqEntry runq_entries = 3;
    RunqEntry runnext = 4;
}

message RunqEntry {
    optional int64 go_id = 1;
    InterpretedPC execution_context = 2;
}

message InterpretedPC {
    optional string file = 1;
    optional int32 line = 2;
    optional string func = 3;
}

message ExecuteEvent {
    optional int64 m_id = 1;
    RunqEntry found = 2;
}

message DelayEvent {
    optional int64 m_id = 1;
    optional int64 go_id = 2;
    InterpretedPC current_pc = 3;
}

message ScheduleEvent {
    optional int64 m_id = 1;
    ScheduleReason reason = 2;
    optional int64  proc_id = 3;
}

enum ScheduleReason {
    GOEXIT = 0;
    GOPARK = 1;
    MSTART = 2;
    OTHER = 20;
}

message NewProcEvent {
    optional int64 creator_go_id = 1;
    InterpretedPC start_pc = 2;
    optional int64 m_id = 3;
}

message StructureId {
    StructureType structure_type = 1;
    optional int64 m_id = 2;
}

enum StructureType {
    LocalRunq = 0;
    GlobalRunq = 1;
    Semtable = 2;
    Executing = 3;
}

service SlowmoService {
    rpc CompileAndRun(CompileAndRunRequest) returns (stream CompileAndRunResponse);
}